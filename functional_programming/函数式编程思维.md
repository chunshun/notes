ex:  读取一个文本文件，确定所有单词的使用频率并从高到低排序，打印出所有单词以及其频率的排序列表。
```java
private List<String> regexToList(String words,String regex){
    List wordList =new ArrayList<>();
    matcher m=Pattern.compile(regex).matcher(words);
    while(m.find())
    wordList.add(m.group);
    return wordList;
}

public Map wordFreq(String words){
    TreeMap<String,Integer> wordMap =new TreeMap<>();
    regexToList(words,"\\w+").stream().map(w-> w.toLowerCase()).filter(w->!NON_WORDS.contains(w)).forEach(w->wordMap.put(w,wordMap.getOrDefault(w,0)+1);
    return wordMap;

}
```
面对对象编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。

高阶函数消除了摩擦。


具有普遍意义的基本构造单元：
1. filter(筛选)：
    筛选是列表的一种基本操作： 根据用户定义的条件来筛选列表中的条目，并由此产生一个较小的新列表。

2. map(映射):
    对原集合的每一个人元素执行给定的元素，从而变成一个新的集合。
    需要就地变换一个集合的时候，用map.

3. 折叠(fold)/化约(reduce)
    用一个累积量来‘收集’集合元素，用一个二元（或多元运算）来结合列表的首元素和累积量的初始值，直到列表耗尽。 此时累积量的取值即为折叠元素的运算结果。
    默认情况下，加为0，乘为1.
    需要把集合分成一小块一小块来从处理的时候，用`reduce`或`fold`。

```javascript
var a=[1,2,2,4]
a.reduce((x,y)=> x+y) //8
a.reduce((x,y)=>x*y)  //16
a.reduce((x,y,z)=>x*y*z) // 1*[1,2,2,4]/ [1*1*2,2,2,4]/[2,2,2,4]/[8,2,4]/96
```

函数的同义异名问题：
1. 筛选
     筛选函数将用户(通常以高阶函数的形式)给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组成的一个子集。
2. 映射
    传唤映射函数的是一个高阶函数和一个返回值，它在对集合中的每一个元素施用传入的函数之后，产生另一个集合作为一个返回值。返回的结合大小与原集合大小相同。
3.  折叠/化约

函数式编程的好处之一是，能够将低层次情节(如垃圾回收)的控制权移交给运行时，从而消弭了一大批注定会发生的错误。


**闭包：**
实际上是一种 特殊的函数，暗中绑定了函数内部引用的所有变量。换句话说，这种函数 (或方法) 把它引用的所有东西都在一个上下文里包了起来。

闭包经常被函数式语言和框架当作一种异地执行的机制，用来传递执行的变换代码。

闭包还是推迟执行原则的绝佳样板，可以推迟到适当的时机再执行闭包。

闭包作为一种对**行为**的建模手段。把代码和上下文封装再单一结构，也就是闭包里面，像传统数据结构一样可以传递到其他位置，然后在恰当的地点和时间完成执行。

**柯里化和函数的部分施用**
两者都可以创建有一部分预设参数值的函数。

柯里化指的是**从一个多参数函数变成一连串参数函数的变换**，他描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。

部分施用指**通过提前带入一部分参数值**，使一个多参数函数可以省略部分参数，从而转化为一个参数数目较少的函数，这种方法叫做部分施用(partial application),就是让函数先作用与其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

process(x,y,z)=>(curry)process(x)(y)(z)
process(x,y,z)=>(partial application)process(y,z)

**递归**


函数式编程的两种常见特性：记忆(memoization))和惰性求值(laziness)
只有纯函数才可以适用缓存技术。纯函数是没有副作用的函数： 他不引用其他值可变的类字段，除返回值之外不设置其他的变量，其结果完全由输入字段决定。

以空间换时间；

记忆： 自动地缓存重复出现的函数返回值。

惰性求值的好处：
1. 可以创建无线长度的序列，由于不需要求解还没用到的元素值，可以用惰性求值集合来建模无线列表。
2.  减少占用的存储空间，加入能够用推导的方法得到后续的值，那就不必预先存储完整的列表了，这是牺牲速度来换取存储空间的做法。
3.  惰性求值有利于运行时产生更高效率的代码。


切断多态和继承之间的耦合关系， 催生了一种更强大的分发机制，这样的分发机制能够处理相当复杂的情况，例如不同图像文件格式的分发问题。，每种格式类型都是各不相同的一组特征来定义的。

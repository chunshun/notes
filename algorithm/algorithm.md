# 动态规划：  
## 分治与动态规划  
分治与动态规划都是将问题分解为子问题，然后归并子问题的解得到原问题的解。但是不同的是， 分治算法解出的子问题是不重叠的，而动态规划解决的问题具有重叠子问题，例如，归并排序与快速排序都是处理左序列与右序列，然后将左右序列的结果结合，过程中不出现重叠子问题，因此他们使用的都是分治法。另外，分治算法解决的问题不一定是最优化问题，而动态规划解决的问题一定是最优化问题
## 贪心与动态规划  
都要求原问题具有最优子结构。二者的区别在于，贪心法采用的计算方法是“自顶向下”，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题就不去求解了，直接抛弃。也就是说，它总是只在上一步选择的基础上继续选择，因此整个问题以一种单链的流水方式进行，显然这种所谓“最优选择”的正确性需要用归纳法证明。而动态规划不管是采用自顶向下还是自底向上的计算方式，都是从边界开始向上得到目标问题的解。也就是说，它总会考虑所有子问题， 并选择继承能得到最优结果的那个，对暂时没被继承的子问题，由于重叠子问题的存在， 后期可能会再次考虑他们，因此还有可能成为全局最优的一部分，不会放弃。 

**对于动态规划可解的问题来说设计的关键在于设计无后效性状态，即当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过自己的状态去影响未来的决策，但并不是所有状态都有无后效性，因此必须设计一个拥有无后效性的状态以及相应的状态转移方程**

1. 最大连续子序列  
令$`dp[i]`$表示以$`A[i]`$作为末尾的连续序列的最大和

2. 最长不降子序列  
令$dp[i]$表示以$A[i]$结尾的最长不下降子序列长度
3. 最长公共子序列  
令$dp[i][j]$表示字符串$A$的$i$ 号位与字符串$B$的$j$号位之前的LCS长度
4. 最长回文子串  
令$`dp[i][j]`$表示$`S[i]`$至$`S[j]`$所比表示的子串是否是回文子串
5. 数塔DP  
令$`dp[i][j]`$表示从第$`i`$行第$`j`$个数字出发的到达最底层的所有路径上所能得到的最大和
6. DAG最长路  
令$`dp[i]`$表示从$`i`$号顶点出发能获得的最长路径长度
6. 背包问题  
令$`dp[i][v]`$表示前$`i`$ 件物品恰好装入容量为$`v`$的背包中能获得的最大价值

